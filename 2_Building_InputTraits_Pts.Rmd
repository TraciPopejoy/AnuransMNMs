---
title: "Building Input Dataframes for MNMs"
date: "10/20/2022"
output: pdf_document
---

```{r setup, include=FALSE}
library(tidyverse); library(knitr); library(ggrepel); library(cowplot)
library(Rphylopars); library(ggtree); library(treeplyr); library(phytools)
library(sf); library(geodata);library(stars)
library(nlme)
knitr::opts_chunk$set(echo = FALSE)
focal_spp<-c('Lithobates catesbeianus', 'Lithobates clamitans', 'Anaxyrus americanus', 'Lithobates sylvaticus', 'Pseudacris crucifer', 'Dryophytes versicolor', 'Acris blanchardi', 'Dryophytes chrysoscelis', 'Lithobates palustris', 'Anaxyrus fowleri', 'Scaphiopus holbrookii', 'Gastrophryne carolinensis', 'Lithobates areolatus')
```

# Trait Imputation Methods

[Penone et al. 2014](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12232) reviewed imputation methods and [Johnson et al. 2021](https://onlinelibrary.wiley.com/doi/full/10.1111/geb.13185) addressed how bias affects the top methods. Generally, using phylogentic information reduces error but bias in trait completeness leads to different methods being *best*.

#### Bias in our trait dataset

In 0_Species_Selection.Rmd, we identified species that have trait data for atleast 3 of the following traits: CTmax, CTmin, Tpref, and Tmerge. 

```{r atraiu2, echo=F, warning=F, message=F}
trait_db<-read_csv('ATraiU 2.0/ATraiU2_summary_values_2022SEPT.csv', show_col_types = F)
knitr::include_graphics("C:/Users/Owner/Desktop/Git/AnuranMNMs/ATraiU 2.0/manuscript/summary_figure_combo.jpg")
```

```{r trait completeness, echo=F}
kable(trait_db %>% 
        dplyr::select(-refIDs, -arrhythmic, -crepuscular, -nocturnal, -diurnal) %>%
        pivot_longer(-species) %>%
        group_by(species) %>% 
        filter(species %in% focal_spp, name !='Tforage_optim')%>% 
        summarize(ntraits=sum(is.na(value)), rel.n.traits=round(ntraits/7,3)*100),
caption='Missing Trait Data among focal species',
col.names = c('Species', 'N missing Traits', 'Missing Data %'))
```

Revisiting how different imputation methods work under bias
```{r, echo=FALSE, fig.cap="", out.width = '90%', out.height='80%', fig.align='center'}
knitr::include_graphics("C:/Users/Owner/Desktop/Git/AnuranMNMs/input_data/Johnson2021_error_trait_imputatoin.png")
```

## Anuran Phylogeny

Using the phylogeny from Jetz & Pyron 2019, we can impute traits for the species we have trait information for. To improve the fit of this imputation, for our focal species, we are recalculating means that remove traits from far locals (e.g., Canada). 

```{r}
new_trait_mean<-read.csv('ATraiU 2.0/ATraiU2_full_2022SEPT.csv') %>%  filter(species %in% focal_spp, 
         lifeStage %in% c('adult','unknown'), 
         traitName != 'Activity', 
         !is.na(verbatimLocality)) %>%
  group_by(species, traitName) %>% mutate(n=n()) %>%
  filter(n != 1) # if only one value, won't exclude
#new_trait_mean$verbatimLocality %>% unique()
trait_filt <- new_trait_mean %>% 
  filter(!(verbatimLocality %in% c("James River and Big Sioux River, South Dakota",
                                 "44.57229Â°N, 97.02486Â°W", 
                                 "45 34'57â€\u009dN 64, 58'37â€\u009dW",
                                 "44Â°33'N, 78Â°33'W", "45Â°35'N, 78Â°30'W",
                                 "44Â°50'N, 68Â°35'W", 
                                 "Meadow Valley Wash between Carp & Elgin, Lincoln County, Nevada",
                                 "Andes of Veneszuela",
                                 "NAD 27: UTM Zone 17: N5127200m, E304000m")), 
          !grepl("48 N, 123 W", verbatimLocality),
          !grepl("South Dakota", verbatimLocality),
           !grepl("northwest", verbatimLocality),
           !grepl("Maine", verbatimLocality),
           !grepl("Minnesota", verbatimLocality),
           !grepl("MN", verbatimLocality),
           !grepl("Ontario", verbatimLocality),
           !grepl("Quebec", verbatimLocality),
         !grepl("Ottawa", verbatimLocality),
           !grepl("British Columbia", verbatimLocality))
trait_restrict <- group_by(species, traitName) %>%
  summarize(mean_val=mean(as.numeric(traitValue)), sd_val=sd(as.numeric(traitValue)))
```

building base maps

```{r}
can<-gadm('can', level=1, tempdir()) %>% st_as_sf()
usa<-gadm('usa', level=1, tempdir()) %>% st_as_sf() %>% 
  filter(!(NAME_1 %in% c('Alaska','Hawaii')))
se<-usa %>% filter(NAME_1 %in% c('Mississippi', 'Georgia', 'Florida', 'South Carolina', 
                           'North Carolina', 'Virginia', 'Alabama', 'Tennessee')) %>%
  st_transform(st_crs("+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=km +no_defs"))
```


```{r}
left_join(usa, trait_filt %>%
  mutate(NAME_1=case_when(grepl('Texas', verbatimLocality) ~ 'Texas',
                      grepl('Missouri', verbatimLocality) ~ 'Missouri',
                      grepl('Illinois', verbatimLocality) | 
                        grepl('IL', verbatimLocality) ~ 'Illinois',
                      grepl('Ohio', verbatimLocality) |
                        grepl(', OH', verbatimLocality) ~ 'Ohio',
                      grepl('New Jersey', verbatimLocality) ~ 'New Jersey',
                      grepl('Kentucky',verbatimLocality) ~ 'Kentucky',
                      grepl('Michigan', verbatimLocality)~'Michigan', 
                      grepl('New York', verbatimLocality) |
                        grepl('NY', verbatimLocality) ~ 'New York',
                      grepl("Maine", verbatimLocality) ~ 'Maine',
                      grepl("Minnesota", verbatimLocality)|
                        grepl('MN', verbatimLocality) ~'Minnesota',
                      grepl('Connecticut', verbatimLocality)~'Connecticut',
                      grepl('Northeast US', verbatimLocality)|
                        grepl('Massachusetts', verbatimLocality)~'Massachusetts',
                      grepl('Indiana', verbatimLocality)~'Indiana',
                      grepl('Pennsylvania', verbatimLocality)~'Pennsylvania',
                      grepl('Arkansas', verbatimLocality)~'Arkansas',
                      grepl('Louisiana', verbatimLocality)~'Louisiana',
                      grepl('Maryland', verbatimLocality)~'Maryland',
                      grepl('Delaware', verbatimLocality)~'Delaware',
                      grepl('rhode island', verbatimLocality) ~ 'Rhode Island',
                      grepl('Kansas', verbatimLocality) ~ 'Kansas',
                      grepl('Oklahoma', verbatimLocality)|
                        verbatimLocality == 'UTM zone 15; 233905E, 4047104N, NAD 83' ~ 'Oklahoma',
                      verbatimLocality %in% c("41 17' N, 83 37' W", "41 17' N, 83 13' W",
                                              "40 37' N, 83 17' W") ~ 'Ohio',
                      verbatimLocality == "44 28'45\"N, 87 37'15\" W" ~ 'Wisconsin',
                      verbatimLocality == "N 0695928 and W 4482919, zone 15 using NAD27 CONUS map datum in UTM" ~ 'Illinois',
         T ~ 'study area')) %>%
    distinct(traitName, NAME_1) %>%
    group_by(NAME_1) %>% summarize(n_traits=length(unique(traitName))),
  by='NAME_1') %>%
  mutate(n_traits = ifelse(NAME_1 %in% c('South Dakota', 'Nevada', "Maine", "Minnesota"), 0,n_traits)) %>%
  ggplot()+
  geom_sf(data=can %>%
            mutate(n_traits=ifelse(NAME_1 %in% c("Ontario","Quebec","British Columbia", "Nova Scotia"), 0, NA)),
          aes(fill=n_traits))+
  geom_sf(aes(fill=n_traits))+
  geom_sf(data=se %>% st_transform(st_crs(usa)), fill='lightgrey')+
  theme_void()
```





```{r phylogeny, echo = F, fig.height=4.5}
taxa_table<-trait_db %>% dplyr::select(species) %>%
  mutate(Tree.name.syn=case_when(species == 'Dryophytes squirellus'~ 'Hyla squirella',
                             species == 'Dryophytes gratiosus'~ 'Hyla gratiosa',
                             species == 'Dryophytes cinereus'~'Hyla cinerea',
                             grepl('Dryophytes',species)~gsub('Dryophytes','Hyla', species),
                             species == 'Lithobates areolatus'~ 'Rana areolata',
                             species == 'Lithobates catesbeianus'~'Rana catesbeiana',
                             species == 'Lithobates sevosus'~'Rana sevosa',
                             species == 'Lithobates sylvaticus'~ 'Rana sylvatica',
                             species == 'Lithobates sphenocephalus'~'Rana sphenocephala',
                             grepl('Lithobates',species)~gsub('Lithobates','Rana', species),
                             T~species),
         Tree.name=sub(' ','_',Tree.name.syn)) %>%
  filter(species != 'Lithobates kauffeldi')

# import phylogeny from Jetz and Pyron 2018
tree_orig <- read.tree(file = "input_data/amph_shl_new_Consensus_7238.tre") 
tree.pruned <- keep.tip(phy = tree_orig, 
                        tip = taxa_table$Tree.name) 
taxa_table$node<-nodeid(tree.pruned, taxa_table$Tree.name)
#plot(tree.pruned, font=2)
```

```{r plot the phylo tree, echo=F, warning=F, message=F}
trait.df<-trait_db %>%
  mutate(category=ifelse(species %in% focal_spp, 'focal', 'SE')) %>%
  right_join(taxa_table, by='species') %>%
            mutate(tree.lab=paste0(substr(Tree.name,1,1), '. ',
                                   sub('.*\\_','',Tree.name))) %>%
  replace_na(list(n=0, comp=0))
trait_tree<-left_join(tree.pruned, trait.df, by='node')
ggtree(trait_tree, aes(color=category, label=tree.lab), size=3)+ 
  geom_tiplab(as_ylab=T)
```

So based on the missing trait data of our focal species, we should either use Rphylopars or BHPMF + phylogeny to impute the missing trait data. I am going to use all the trait data available across the entire Southeast US anuran species group (n = 40 species) to impute the data.

## Use Rphylopars to imput continuous trait data

```{r trait mat, warning=F, message=F, echo=F}
trait.mat.m<-trait.df[, c(18, 6:10, 12:14)] %>%
  rename('species'='Tree.name')
# note to self : incorporate interspecific traits?
read.csv('ATraiU 2.0/ATraiU2_full_2022SEPT.csv') %>%
  filter(lifeStage %in% c('unknown','adult')) %>%
  select(species, verbatimLocality, traitName, traitValue) %>%
  pivot_wider(names_from=traitName, values_from=traitValue)
```
We use the following code to impute the traits using the *Rphylopars* package. 
- estimates phylogenetic and phenotypic variance-covariance matrices 
- assumes phenotypic covariance is equivalent among species
- uses a Browning motion model of evolution
Essentially is a maximum likelihood frequentist way to impute traits

```{r results, echo=T, out.width='60%'}
p_BM <- phylopars(trait_data = data.frame(trait.mat), tree = tree.pruned,
                  phylo_correlated=F, model='BM')
p_lamda <- phylopars(trait_data = data.frame(trait.mat), tree=tree.pruned,
                     phylo_correlated=F, model= "lambda")
p_OU <- phylopars(trait_data = data.frame(trait.mat), 
                  tree = force.ultrametric(tree.pruned),
                  phylo_correlated=F, model='OU')
```


```{r phyomodel out, echo=F}
kable(data.frame(model=c('lambda','Brownian motion','OU'),
                 df=c(p_lamda$npars, p_BM$npars, p_OU$npars),
                 loglik=round(c(p_lamda$logLik, p_BM$logLik, p_OU$logLik),2)) %>%
        mutate(AIC =round(c(AIC(p_lamda),AIC(p_BM), AIC(p_OU)), 2)) %>%
        arrange(AIC),
      caption='Best model for phylogenetic imputation')
```

```{r}
summary(p_OU)
```

```{r results graph,  fig.height=4, echo=F}
#results!
imp_results <- p_OU$anc_recon[1:length(tree.pruned$tip.label),] %>%
  as_tibble() %>%
  bind_cols(species=rownames(p_OU$anc_recon[1:length(tree.pruned$tip.label),])) %>%
  left_join(trait.mat, by='species')%>%
  pivot_longer(-species) %>%
  mutate(variable=gsub('.y','', gsub('\\.x','', name)),
         impute=ifelse(grepl('y',name), 'No','Yes'))  %>%
  dplyr::select(-name) %>%
  pivot_wider(names_from = impute, values_from=value)  %>%
  mutate(Imputed=ifelse(is.na(No), 'Imputed', 'Literature'),
         genus=gsub("\\_.*", "\\1", species),
         family=case_when(genus %in% c('Acris','Hyla','Pseudacris') ~ 'Hylidae',
                          genus %in% c('Anaxyrus','Incilius') ~ 'Bufonidae',
                          genus %in% c('Lithobates','Rana') ~'Ranidae',
                          genus == 'Gastrophryne'~'Microhylidae',
                          genus == 'Scaphiopus' ~ 'Scaphiopodidae')) 
imp_results %>%
  ggplot(aes(x=family, y=Yes, color=Imputed))+
  geom_boxplot(color='black', fill=NA, outlier.alpha = 0)+
  geom_point(position=position_dodge(width=0.5))+
  facet_wrap(~variable, scales='free_y')+
  labs(x='Family',y='Value')+
  scale_color_manual(values=c('forestgreen','goldenrod'))+
  theme_classic() +
  theme(legend.position='top',
        axis.text.x = element_text(angle=20, hjust=.87, vjust=1))
```

```{r species discussion, echo=F}
kable(imp_results  %>%
        left_join(taxa_table, by=c('species'='Tree.name')) %>%
        rename(Tree.name=species, species=species.y) %>%
        filter(species %in% focal_spp) %>%
  group_by(species) %>%
  count(Imputed) %>% 
  filter(Imputed == "Imputed") %>%
  mutate(perimp=round(n/8,3)) %>%
  ungroup() %>% summarize(summary(n), summary(perimp)) %>%
    mutate(row.names=c('min','.25','median','mean','.75','max')) %>%
    select(row.names, everything()),
  col.names=c('parameter', 'N traits','% traits'),
  caption='Summary of imputed traits')
```

This gives us `r imp_results  %>% left_join(taxa_table, by=c('species'='Tree.name')) %>% rename(Tree.name=species, species=species.y) %>% filter(species %in% focal_spp) %>% group_by(species) %>% count(Imputed) %>% filter(Imputed == "Imputed") %>% ungroup() %>% summarize(sum(n)) %>% as.numeric()` traits (of a possible `r length(focal_spp)` x 8 = `r length(focal_spp)*8`). 

```{r rcs focal sp plot, echo=F, fig.height=2.75, fig.width=5}
rcs<-read_csv('C:/Users/Owner/Desktop/Git/National-RCS/Anuran_RCS_and_components_20220908.csv',
              show_col_types=FALSE) %>% 
  filter(grepl('North', extent)) %>%
  dplyr::select(species, genus, family, AOO_WS_sqkm, RCS_WS) %>%
  # manually adding in 'Lithobates sevosus' information
  bind_rows(data.frame(species='Lithobates sevosus', 
                       genus='Lithobates',family='Ranidae',
                       AOO_WS_sqkm=737.8, RCS_WS=1.0001)) %>%
  mutate(rankRCS=91-rank(RCS_WS))
imp_results %>%
  left_join(taxa_table, by=c('species'='Tree.name'))%>%
  dplyr::select(-species) %>% rename(species = species.y) %>%
  group_by(species) %>%
  summarize(n_imp=sum(Imputed=='Imputed'), .groups='drop') %>%
  left_join(rcs, by='species') %>%
  ggplot(aes(x=RCS_WS, y=n_imp))+
  geom_point()+
  geom_text_repel(data=. %>% filter(n_imp<5), aes(label=species), 
                  min.segment.length = .01, size=2.5)+
  labs(y='Number of Imputed Traits',
       x='RCS index - North American extent, watershed grain size')+
  theme_classic()
```

## Outputting the trait tables to query for MNMs

```{r}
atraiu<-read_csv('C:/Users/Owner/Downloads/ATraiU/ATraiU_summary_values_2020AUG.csv', 
                 show_col_types = F)
used_traits<-imp_results %>% #imputed thermoregulation traits
  select(species, variable, Yes, Imputed) %>%
  group_by(species) %>%
  # tally imputed traits to keep track
  mutate(imp.trait=paste(ifelse(Imputed=='Imputed', variable, ''), collapse=''),
         n.imp=sum(Imputed=='Imputed')) %>%
  select(-Imputed) %>%
  pivot_wider(names_from=variable, values_from=Yes) %>%
  # join in taxonomic information
  rename(Tree.name=species) %>% left_join(taxa_table, by='Tree.name') %>%
  # filter to only the focal species
  filter(species %in% focal_spp) %>% ungroup() %>%
  select(-node, -Tree.name.syn, -Tree.name) %>%
  # bring in ATraiU for burrowing & climbing
  left_join(atraiu %>% select(family, latin_name, s.fossorial, s.arboreal),
            by=c('species'='latin_name')) %>%
  # bring in categorical activity data
  left_join(read.csv('ATraiU 2.0/ATraiU2_summary_values_2022SEPT.csv') %>%
              dplyr::select(species, nocturnal, diurnal, crepuscular) %>%
              mutate(across(-species, ~ifelse(.x > 0,1,0))), by='species') %>%
  # reorder so column order is nicer
  select(family, species,imp.trait, n.imp, s.fossorial, s.arboreal, 
         nocturnal, diurnal, crepuscular, everything()) %>%
  # estimating activity traits for Lithobates areolatus
  mutate(nocturnal=case_when(species=='Lithobates areolatus'~ 1, T~nocturnal),
         diurnal=case_when(species == 'Lithobates areolatus'~0, T~diurnal),
         crepuscular = case_when(species == 'Lithobates areolatus' ~ 0, T~crepuscular),
         s.fossorial = as.numeric(s.fossorial),
         s.arboreal = as.numeric(s.arboreal)) 
write.csv(used_traits, 'input_data/inputed_physio_traits.csv', row.names=F)
```

```{r, fig.width=5, fig.height=2, echo=F}
nictp<-theme_classic()+
  theme(axis.text.x = element_text(angle=25, hjust=.9, size=9))
plt.df<-used_traits %>% mutate(pltsp=paste0(substr(species, 1,1), '. ', 
                                            sub(".*? ", "", species)))
#mass
ggplot(plt.df, aes(x=family, y=Mass, label=pltsp)) +
  geom_point() + geom_text_repel(size=3)+
  scale_y_log10('Wet Mass, g', breaks=c(1, 10, 50, 100, 250))+nictp
```



```{r thermal traits, fig.width=7, fig.height=2.5, echo=F}
# thermal limits & scope
plt.df %>% select(family, pltsp, CTmax, CTmin) %>%
  mutate(CTscope=CTmax - CTmin) %>%
  pivot_longer(-c(family, pltsp)) %>%
  ggplot(aes(x=family, y=value, label=pltsp)) +
  geom_point() + geom_text_repel(size=2.5)+
  facet_wrap(~name, scales='free_y')+nictp
# tbask & tforage
plt.df %>% select(family, pltsp, Tbask, Tforage_min, Tforage_max) %>%
  pivot_longer(-c(family, pltsp)) %>%
  ggplot(aes(x=family, y=value, label=pltsp)) +
  geom_point() + geom_text_repel(size=2.5)+
  facet_wrap(~name, scales='free_y')+nictp
```
```{r other temp traits, fig.width=5, fig.height=2.5}  
# emergence temperature
plot_grid(ggplot(plt.df, aes(x=family, y=Tmerge, label=pltsp)) +
  geom_point() + geom_text_repel(size=3)+
    scale_y_continuous('Emergence Temperature, Celcius')+nictp,
# tpref
ggplot(plt.df, aes(x=family, y=Tpref, label=pltsp)) +
  geom_point() + geom_text_repel(size=3)+
  scale_y_continuous('Preferred Temperature, Celcius')+nictp)
```

# Exploring accounting for Acclimation using data from ATraiU-TaDS

So one issue is that we know there is intraspecific variation in critical thermal maxima and other thermoregulation trait values. We could try to build curves to control for this acclimation-driven variation in CTmax. Essentially we would derive a function between acclimation temperature and CTmax for each species (if possible). We would then apply that function across a raster of mean temperature during the warmest quarter (WorldClim bioclim variable I think). Then, before running the ectotherm model, we would pull the acclimation-adjusted CTmax for that location. 

First, lets explore the information we have about acclimation ability in SE Anurans. We find that there are only six species that had different acclimation temperatures and CTmax values.

```{r}
all_traits<-read.csv('ATraiU 2.0/ATraiU2_full_2022SEPT.csv')
#head(all_traits)
CTmax_acc<-all_traits %>% 
  filter(traitName=='CTmax', 
         lifeStage %in% c('adult','unknown'),
         !is.na(traitAcclimation)) %>%
  mutate(traitAcclimation=case_when(traitAcclimation == '4C and 14C' ~ 14,
                                    traitAcclimation == '20 to 24' ~ 22,
                                    T ~ as.numeric(traitAcclimation)),
         traitValue = as.numeric(traitValue)) 
```

```{r spp with acc info, echo=F}
kable(CTmax_acc %>% 
  filter(species %in% focal_spp) %>%
  group_by(species) %>% 
  mutate(n=n(), range=max(traitAcclimation)-min(traitAcclimation)) %>%
  filter(n >1, range > 0) %>%
  summarize(meanCTmax=round(mean(traitValue),2), 
            sdCTmax=round(sd(traitValue),2), 
            accRange=mean(range), nPts=mean(n)),
  caption='Species with more than one acclimation temperature available for adult CTmax trait values',
  col.names = c('Species', 'Mean CTmax', 'sd CTmax', 'Acclimation temp. range', 'N CTmax values'))
```

That being said, it does look like there is some variation in acclimation ability. The lines below represent CTmax as a function of log(acclimation temperature) for quick analysis; the black line represents the function using all SE Anuran data. 

```{r acclimation plot, echo=F, fig.width=6, fig.height=2.75}
CTmax_acc %>% ggplot(aes(x=traitAcclimation, y=traitValue))+
  geom_smooth(method="lm", formula=y~log(x), se=50, color='black')+
  geom_smooth(data=. %>% filter(species %in% c('Anaxyrus fowleri',
                                               'Lithobates catesbeianus',
                                               'Lithobates clamitans',
                                               'Lithobates palustris',
                                               'Lithobates sylvaticus',
                                               'Scaphiopus holbrookii')),
              aes(color=species),
              method="lm", formula=y~log(x), se=0)+
  geom_text_repel(data=. %>% 
                    group_by(species) %>% 
                    filter(species %in% c('Anaxyrus fowleri', 'Lithobates catesbeianus',
                                          'Lithobates clamitans', 'Lithobates palustris',
                                          'Lithobates sylvaticus', 'Scaphiopus holbrookii'),
                                    traitAcclimation == max(traitAcclimation)) %>%
                    distinct(species, traitAcclimation, .keep_all=T),
                  aes(label=species), size=2.5,
                  min.segment.length = 0, nudge_x = 5)+
  geom_point(aes(color=species))+theme_classic()+
  scale_y_continuous('Measured Critical Thermal Maxima')+
  scale_x_continuous('Acclimation Temperature')+
  theme(legend.position='none')+
  ggtitle('Potential acclimation curves')
```

I think I don't have enough data to calculate species' level acclimation curve, even for species with more than two points. I apply the formula describbed in Comte & Olden 2017 to account for variation in CTmax when estimating warming tolerance across species ranges for both freshwater and marine fish. 
$$ CTmax = b + (a - b)e^x $$

where a is the intercept on the y axis, b is the asymptote (maximum CTmax), and x is c*Acclimation temperature (where c is a pseudo-acclimation rate). 

Below I calculate a single acclimation curve for all SE Anurans, acclimation curves where CTmax intercept, CTmax asymptote, and pseudo-acclimation rate vary among family individually, and an acclimation curve where both CTmax intercept and CTmax asymptote vary among families (Comte & Olden 2017 for fish). I could not get the models to converge when I used species as the random factor, even when restricting to the 6 species with multiple acclimation points (likely because median n = 4 points). 

```{r}
df<-CTmax_acc %>% dplyr::select(family, traitValue, traitAcclimation) %>%
  rename(y=traitValue, x=traitAcclimation)
#length(unique(df$family))

allSE<-nls(y~b+(a-b)*exp(c*x), data=df, start=c(a=10, b=40, c=-0.1))
asy<-nlme(y~b+(a-b)*exp(c*x), data=df, 
             random=b~1|family, fixed=a+b+c~1,
             start=c(a=10, b=40, c=-0.1),
             control=nlmeControl(pnlsTol=.1, msMaxIter=1e6, tolerance=1e-4))
int<-nlme(y~b+(a-b)*exp(c*x), data=df, 
             random=a~1|family, fixed=a+b+c~1,
             start=c(a=10, b=40, c=-0.1),
             control=nlmeControl(pnlsTol=10, msMaxIter=1e7, tolerance=1e-4))
rate<-nlme(y~b+(a-b)*exp(c*x), data=df, 
             random=c~1|family, fixed=a+b+c~1,
             start=c(a=10, b=40, c=-0.1),
             control=nlmeControl(pnlsTol=.1, msMaxIter=1e6, tolerance=1e-4))
asyint<-nlme(y~b+(a-b)*exp(c*x), data=df, 
             random=a+b~1|family, fixed=a+b+c~1,
             start=c(a=10, b=40, c=-0.1),
             control=nlmeControl(pnlsTol=1, msMaxIter=1e7, tolerance=1e-4))
```

We find that two related top models. CTmax asymptote definitely varies by family and the model that has CTmax asymptote + CTmax intercept vary among families is second best because of increased df penalization. The below plot uses the family-level asymptote and intercept models for the lines, with the CTmax's calculated by trait imputation marked by triangles and at acclimation temperature 31. Because these functions reduce interspecific variation within families, I am leaning towards not accounting for acclimation with this method for our analysis. 

```{r acc model outputs, echo=F}
kable(tibble(anova(asy, int, rate, asyint, allSE)) %>%
  dplyr::select(Model:logLik) %>%
  mutate(`Model name`=c('asy','int','rate','asyint','allSE')) %>%
  arrange(desc(logLik)),
  caption='Models relating acclimation temperature to CTmax')
summary(asyint)
```

```{r plot what acclimation looks like, echo=F, fig.width=6, fig.height=4}
sapply(predict(asyint, 
        data.frame(x=rep(seq(5,30,1), each=5),
                   family=rep(unique(df$family), 26)), asList=T), '[') %>%
  as_tibble() %>% pivot_longer(everything()) %>%
  mutate(x=rep(seq(5,30,1), each=5)) %>%
  ggplot()+
  geom_point(data=CTmax_acc, aes(y=traitValue, x=traitAcclimation, color=family))+
  geom_line(aes(x=x, y=value, color=name))+
  geom_text_repel(data=used_traits %>%
              mutate(pltsp=paste0(substr(species, 1,1), '. ', 
                                            sub(".*? ", "", species))),
             aes(x=31, y=CTmax, label=pltsp),hjust=0, size=2,
             min.segment.length = 0)+
  geom_point(data=used_traits,
             aes(x=31, y=CTmax, color=family), alpha=0.8,  pch=2, size=2)+
  scale_y_continuous('CTmax temperature')+
  scale_x_continuous('Acclimation temperature', expand=c(0.15,.15))+
  theme_classic()
```

```{r}
all_traits %>%
  filter(species %in% focal_spp,
         traitName == 'CTmax',
         lifeStage %in% c('unknown','adult')) %>%
  mutate(traitValue = as.numeric(traitValue)) %>%
  # only keep maximum CT for each population
  group_by(species, verbatimLocality) %>% 
  filter(traitValue == max(traitValue)) %>%
  # calculate min, median and max across populations
  group_by(species) %>%
  summarize(minCTmax=min(traitValue),
            medCTmax=median(traitValue),
            maxCTmax=max(traitValue)) %>%
  mutate(CTmax_range=maxCTmax-minCTmax) %>%
  arrange(desc(CTmax_range)) %>%
  filter(CTmax_range > 0)

```

# Downloading NCEP data 
```{r download ncep, eval=F}
# Code by Mike Kearney!
library(curl)
years <- seq(2015,2018)
vars <- c('tmax.2m.gauss.','dswrf.sfc.gauss.', 'prate.sfc.gauss.', 'vwnd.10m.gauss.',
          'uwnd.10m.gauss.', 'air.2m.gauss.', 'tmin.2m.gauss.', 'shum.2m.gauss.',
          'pres.sfc.gauss.', 'dlwrf.sfc.gauss.', 'ulwrf.sfc.gauss.', 'tcdc.eatm.gauss.')
for(year in years){
  for(j in 1:length(vars)){
    curl_download(paste0("ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis2/gaussian_grid/",vars[j],year, ".nc"), 
                  paste0("../ncep_data/",vars[j],year, ".nc"),quiet=TRUE, mode="wb")   
  }
}
library(ncdf4)
dir2do <- "../ncep_data/"
setwd(dir2do)
files<-list.files()
files<-files[grep(".nc", x = files)]
vars4 <- c("tmin", "tmax", "air", "shum", "uwnd", "vwnd")
vars3 <- c("pres", "tcdc", "dswrf", "dlwrf", "ulwrf", "prate")
allvars <- c(vars4, vars3)
for(i in 1:length(files)){
  filenm <- files[i]
  orig <- nc_open(filenm)
  t<-ncvar_get(nc = orig, varid = "time", start = 1, count = -1)
  
  varid <- names(orig$var)[which(names(orig$var) %in% allvars)]
  
  if(varid %in% vars3){
    start <- c(1,1,1) # compose the start location vector for getting the data out of the ncdf file for this location
    count <- c(-1,-1,-1) # how much data are wanted? (-1 means all)
  }else{
    start <- c(1,1,1,1) # compose the start location vector for getting the data out of the ncdf file for this location
    count <- c(-1,-1,-1,-1) # how much data are wanted? (-1 means all)
  }
  
  data <- as.numeric(ncvar_get(orig, varid = varid, start = start, count)) # get the data
  lon<-ncvar_get(nc = orig, varid = "lon", start = 1, count = -1) # longitudes
  lat<-ncvar_get(nc = orig, varid = "lat", start = 1, count = -1) # latitudes
  t2 <- ncdim_def(name = "time", units = " hours since 1800-1-1 00:00:0.0", vals = t, unlim=FALSE) # define a time variable
  lon2 <- ncdim_def(name = "lon", units = "degrees_east", vals = lon, unlim=FALSE) # define a longitude variable
  lat2 <- ncdim_def(name = "lat", units = "degrees_north", vals = lat, unlim=FALSE) # define a latitude variable
  att<-ncatt_get(orig, varid, attname=NA, verbose=FALSE) # get attributes from original file
  if(varid %in% vars4){
    level<-ncvar_get(nc = orig, varid = "level", start = 1, count = -1) # levels
    level2 <- ncdim_def(name = "level", units = "m", vals = level, unlim=FALSE) # define a latitude variable
  }
  
  
  if(varid %in% vars3){
    var1 <- ncvar_def(name = varid, units = att$units, dim = list(lon2,lat2,t2), missval = att$missing_value, longname = att$long_name, prec='float') # define the variable
  }else{
    var1 <- ncvar_def(name = varid, units = att$units, dim = list(lon2,lat2,level2,t2), missval = att$missing_value, longname = att$long_name, prec='float') # define the variable
  }
  
  vars <- list(var1) # get variable definition
  file2<-gsub('.nc', replacement = '_time2.nc', x = filenm) # make a new file name
  file3<-gsub('.nc', replacement = '_time.nc', x = filenm) # make a new file name
  ncnew <- nc_create(file2,vars) # create a new ncdf file to put the data in
  ncvar_put(ncnew,var1,data) # put the data in
  nc_close(ncnew) # close the new file
  if(varid %in% vars3){
    cmd<-paste0("ncpdq -a lon,lat,time ",file2," ",file3) # command for ncpdq - permute to reverse order
  }else{
    cmd<-paste0("ncpdq -a lon,lat,level,time ",file2," ",file3) # command for ncpdq - permute to reverse order
  }
  
  system(cmd) # run ncpdq
  
  file.remove(file2) # delete the temporary file
}
```

```{r length microclim, fig.width=6, fig.height=1.5, echo=F}
microtest<-read.csv('micro_20221111.csv')
plot_grid(microtest %>% 
  mutate(obj.size.n=as.numeric(gsub(' Mb', '', obj.size))) %>%
  ggplot()+
  geom_col(aes(x=nyear, y=obj.size.n))+
    scale_y_continuous('Size of model\nMb')+
  scale_x_continuous('Model temporal length, years', breaks=1:9)+
    theme_bw(),
  microtest %>% 
  ggplot()+
  geom_col(aes(x=nyear, y=totaltime))+
    scale_y_continuous('Time to build model\nminutes')+
  scale_x_continuous('Model temporal length, years', breaks=1:9)+
    theme_bw())
```

# Building points at which to run the MNMs

Now that I have the species pool, I identify points to run the models across a species range. The code chunk below creates a grid across the southeastern US that we will use to get the points we will use as inputs into the microclimate model. 

```{r}
anura.tax<-read.csv('input_data/inputed_physio_traits.csv')
focal_spp<-anura.tax %>% pull(species) %>% unique()

se<-st_as_sf(map('state',c('mississippi', 'georgia', 'florida', 'south carolina', 
                           'north carolina', 'virginia', 'alabama', 'tennessee'), 
                 fill=T, plot=F)) %>%
  st_make_valid() %>%
  st_transform(st_crs("+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=km +no_defs"))
```


I will populate a grid at the resolution of our microclimate model on the high power computer (not enough memory on my laptop). First, I need to build range estimates to populate this grid. I do this by using the point occurrences from the RCS analysis, removing points outside 100km of the species' IUCN range (when available), adding a 5km buffer, and taking the union of all points to get an area of occupancy for each frog species. 

```{r}
# bring in the IUCN range shapefile to filter point occurrences
iucn_all<-read_sf('../ANURA') %>% 
  filter(binomial %in% focal_spp, # only keep species we are interested in
         !grepl('Extinct',legend)) %>% # only keep ranges that are extant or introduced
  group_by(binomial) %>% summarize() %>%
  st_buffer()
# first we pull in each species' occurrence points from GBIF & HerpMapper
anuran_pts<-NULL
for(s in focal_spp){
  anuran_pts<-bind_rows(anuran_pts,
                        read.csv(paste0('../National-RCS/data/occ_data/',s,'_20210330.csv')) %>% 
                        # only keep this information about the occurrence point
                          dplyr::select(source, species, Longitude, Latitude,
                                        coordinateUncertaintyInMeters, coordinatePrecision, elevation, 
                                        day, month, year))
}
```


```{r}
aoos<-anuran_pts %>%  
  st_as_sf(coords=c('Longitude','Latitude'), crs=st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")) %>%
  st_join(se %>% st_make_valid() %>% st_transform("+proj=longlat +ellps=WGS84 +datum=WGS84")) %>%
  filter(!is.na(ID)) %>%
  group_by(species) %>%
  summarize(n=n(),
            medyear=median(year, na.rm=T),
            year25=quantile(year, .25, na.rm=T),
            year75=quantile(year,.75, na.rm=T)) %>%
  st_buffer(5) 
aoos %>%
  bind_cols(area=st_area(.))
  
```

```{r, fig.height=2.7, fig.width=6.5}
iucn_all<-read_sf('../ANURA') %>% 
  filter(binomial %in% focal_spp,
         !grepl('Extinct',legend)) %>%
  group_by(binomial) %>% summarize() 
latlist_iucn<-NULL
for(i in iucn_all$binomial){
  latlist_iucn<-bind_rows(latlist_iucn,
            iucn_all %>%
    filter(binomial == i) %>%
    st_rasterize(dx=.5, dy=.5) %>%
   # st_as_sf(as_points = TRUE, merge = FALSE) %>%
    st_coordinates() %>%
    as_tibble() %>% mutate(species=i))
} 

na_r<-st_bbox(c('xmin'=-140, 'ymin'=0, 'xmax'=-40, 'ymax'=70))%>%
  st_as_sfc() %>% st_sf(crs=st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")) %>%
  st_rasterize(dx=.5, dy=.5) %>%
  st_as_sf(as_points = FALSE, merge = FALSE) %>%  #turn into a polygon
                       rowid_to_column()
iucnrng<-st_join(na_r, iucn_all) %>% filter(!is.na(binomial)) %>% st_centroid()
latlist_iucn <-st_coordinates(iucnrng) %>% 
  bind_cols(species=iucnrng$binomial)
rm(iucnrng)
se_dl <- se %>% 
  st_transform(st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")) %>%
  st_rasterize(dx=.5, dy=.5) %>% #turn into a raster of 1x1 kilometers
  st_as_sf(as_points = FALSE, merge = FALSE) %>%  #turn into a polygon
                       rowid_to_column()
pt1<-anuran_pts %>%  
  st_as_sf(coords=c('Longitude','Latitude'), 
           crs=st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")) %>%
  st_join(se_dl) %>% filter(!is.na(rowid)) %>%
  distinct(species, rowid, .keep_all = T)
latlist_occs<-st_coordinates(pt1) %>% bind_cols(species=pt1$species)
```

```{r range lat density graph, echo=F, fig.height=3, fig.width=6.5}
max.lat<-st_bbox(se %>% st_transform(st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")))[4]
min.lat<-st_bbox(se %>% st_transform(st_crs("+proj=longlat +ellps=WGS84 +datum=WGS84")))[2]
latlist_iucn %>%
            mutate(dist='IUCN range') %>%
            bind_rows(latlist_occs %>% 
                        mutate(dist='occurrences')) %>%
  left_join(anura.tax %>% distinct(family, species), by='species') %>%
   mutate(pltsp=paste0(substr(species, 1,1), '. ', sub(".*? ", "", species))) %>%
  ggplot()+
  geom_density(aes(x=Y, fill=dist, color=dist), alpha=0.8)+
  geom_vline(xintercept=c(min.lat,max.lat))+
  scale_x_continuous('Latitude')+
  scale_y_continuous('Proportion of Range', breaks=c(0,.1,.2,.3,.4))+
  #scale_color_manual('species', values=c(met.brewer('Renoir'), 'grey'),
  #                   aesthetics = c('fill','color')) +
  #facet_grid(dist~family)+
  facet_wrap(~species) +
  scale_fill_grey('Source of Range', labels=c('IUCN range','5km buffered point occurrences'),
                  aesthetics=c('color','fill'))+
  theme_classic()+theme(axis.title=element_text(size=9),
                        axis.text=element_text(size=9),
                        legend.position = 'bottom', 
                        legend.title=element_text(size=8),
                        legend.text = element_text(size=8),
                        legend.margin=margin(t=-10),
                        strip.text=element_text(face='italic'),
                        strip.background = element_blank())
  #guides(fill=guide_legend(nrow=3, size=.5, alpha=1))
ggsave('results/FigS3_propdist_lat.jpg', height=4.5, width=6.5)
rm(iucn_all, iucnrng, latlist_iucn, latlist_occs, na_r)
```
```{r}
latlist %>%
  group_by(species) %>% summarize(percent.dist.below.max.lat=round(ecdf(y)(max.lat)*100,2)) %>%
  arrange(percent.dist.below.max.lat)

```  


Now that we've have that grid, we then populate the grid with known occurrences for our focal species. Within each grid, we then identify the point with the lowest distance to all other points (and maximum year if that point is represented multiple times). We will create a 2020 microclimate for that point, which will be used as input for all species occupying that grid cell. This loses some of the biology associated with the point occurrence (location & year information) but does make sure that the comparisons are based on the ecotherm model, not subtle differences in the microclimate model. 


